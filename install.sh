#!/usr/bin/env bash

# Script to install Emacs and other stuff on (hopefully) any GNU/linux system without root privileges.
# It uses Nix (package manager)
# https://github.com/nix-community/nix-user-chroot
# This script was tested on Ubuntu
# Warning: This script will change append things to your ~/.bashrc

# Libs
if [ ! -s ./array ]; then
    wget https://raw.githubusercontent.com/krebs/array/master/array -O ./array
fi
. ./array # POSIX compliant arrays

DIR=~/.nix
LOCALPATH=~/.local/bin
TRASH=$(array $DIR $(readlink -f $0) $(readlink -f ./array) ~/.nix{,-profile,-defexpr,-channels}) # Files to be deleted

# Color variables
RED="\033[0;31m"
GREEN="\033[0;32m"
BLUE="\033[0;34m"
NC="\033[0m"

#### Functions ####
echo "#!/usr/bin/env sh
runNix() (
    # Run a command inside Nix environment
    command=\$*
    echo \$command | nix-user-chroot ~/.nix bash -l
)
runNix \$*" > $LOCALPATH/runNix.sh
chmod u+x $LOCALPATH/runNix.sh
TRASH=$(array_append "$TRASH" $LOCALPATH/runNix.sh)
. $LOCALPATH/runNix.sh 2> /dev/null

askYesNo() (
    # Return 1 for true or 0 for false
    # Arguments: <Message> <default value (true | false)>
    QUESTION=$1
    DEFAULT=$2
    if [ "$DEFAULT" = true ]; then
            OPTIONS="[Y/n]"
            DEFAULT="y"
        elif [ "$DEFAULT" = false ]; then
            OPTIONS="[y/N]"
            DEFAULT="n"
    else
	    OPTIONS="[y/n]"
	    DEFAULT="none"
    fi
    read -p "$QUESTION $OPTIONS " -n 1 -s -r INPUT
    #If $INPUT is empty, use $DEFAULT
    INPUT=${INPUT:-$DEFAULT}
    printf "%s\n" $INPUT
    if [[ "$INPUT" =~ ^[yY]$ ]]; then
        return 1
        elif [[ "$INPUT" =~ ^[nN]$ ]]; then
        return 0
    else
	    printf "Error. Type \"y\" or \"n\"\n"
	    askYesNo "$1" "$2"
    fi
)

genDesktopFile() {
    # Takes the .desktop filename (without the extension) and generates a
    # .desktop file that can be used on the standard user environment.
    # The .desktop file must be generated by Nix
    name=$1
    sufix="${name}-nix"

    mkdir -p ~/.local/share/applications/
    mkdir -p ~/.local/share/icons/
    runNix cp ~/.nix-profile/share/applications/${name}.desktop ~/.local/share/applications/${sufix}.desktop
    chmod u+rw ~/.local/share/applications/${sufix}.desktop
    echo "nix-user-chroot ~/.nix bash -l -c $name" > ~/.local/share/applications/${sufix}.sh
    chmod u+x ~/.local/share/applications/${sufix}.sh
    sed -Ei 's|^Exec=.*|Exec='"${HOME}/.local/share/applications/${sufix}"'.sh|' ~/.local/share/applications/${sufix}.desktop
    runNix cp ~/.nix-profile/share/icons/hicolor/scalable/apps/${name}.svg ~/.local/share/icons/${name}.svg
    sed -Ei 's|^Icon=.*|Icon='"${HOME}/.local/share/icons/${name}"'.svg|' ~/.local/share/applications/${sufix}.desktop
    
    TRASH=$(array_append "$TRASH" ~/.local/share/applications/{${sufix}.desktop,${sufix}.sh} ~/.local/share/icons/${name}.svg)
}

helpf() {
    printf "Usage: %s [OPTIONS]... [ARGS]...\n" $0
    printf "Running this script without args will download dependencies, install nix and create nix related scripts.\n\n"
    printf "[OPTIONS]
-i\tInstall things [ fonts | clangd | emacs | swipl ]
-a\tEquivalent to '-i fonts emacs'
-h\tHelp (show this message)\n"

    exit
}

## Tasks functions
installFonts() {
    printf "Installing Fira Code font\n"
    file="Fira_Code.zip"
    fonts_dir=~/.local/share/fonts
    if [ ! -d ${fonts_dir} ]; then
        mkdir -p ${fonts_dir}
    fi

    curl -s https://api.github.com/repos/tonsky/FiraCode/releases/latest |
    grep "tag_name" |
    awk '{print "https://github.com/tonsky/FiraCode/releases/download/" substr($2, 2, length($2)-3) "/Fira_Code_v" substr($2, 2, length($2)-3) ".zip"}' |
    wget -i - -O $file
    unzip -o -q -d $fonts_dir $file
    
    TRASH=$(array_append "$TRASH" $(readlink -f $file) ${fonts_dir}/{README.txt,specimen.html,fira_code.css} ${fonts_dir}/*/FiraCode-*)
    fc-cache -f
}

### Clangd can be installed through Emacs lsp package
installClangd() {
    wget https://github.com/clangd/clangd/releases/download/15.0.3/clangd-linux-15.0.3.zip -O ~/.local/clangd.zip
    unzip ~/.local/clangd.zip -d ~/.local/
    cp -arf ~/.local/clangd_15.0.3/** ~/.local/
    TRASH=$(array_append "$TRASH" ~/.local/{LICENSE.TXT,clangd.zip,clangd_15.0.3/,bin/clangd})
}

#### Parsing command-line options ####
clopts=($*)
#teste=$(echo "echo \$${test}" | bash)
all=0
while getopts ":i:ah" opt
do
   case "$opt" in
        a ) all=1 ;;
        i ) install="$OPTIND" ;;
        c ) parameterC="$OPTARG" ;;
        h ) helpf ;;
        ? ) printf "Parameter not found. Type $0 -h for help\n"; exit ;; # Print helpFunction in case parameter is non-existent
   esac
done

#### Checking the system #####

if ! ([ $(unshare --user --pid echo YES) = "YES" ] || [ $(echo -n "$( zgrep CONFIG_USER_NS /proc/config.gz )" | tail -c 1) = 'y' ] || [ $(echo -n "$( grep CONFIG_USER_NS /boot/config-$(uname -r) )" | tail -c 1) = 'y' ]); then
    printf "The kernel does not support user namespaces. Installation failed.\n"
    exit
fi

# Check if all required packages are installed
reqpkg=(curl grep awk wget unzip sed) ;
installed_pkg=( $(which ${reqpkg[@]} | awk -F/ '{ print $NF }') )
if [ "${installed_pkg[*]}" != "${reqpkg[*]}" ]; then
    # Array subtraction
    diff() {
	awk 'BEGIN{RS=ORS=" "}
       {NR==FNR?a[$0]++:a[$0]--}
       END{for(k in a)if(a[k])print k}' <(echo -n "${!1}") <(echo -n "${!2}")
    }
    #reqpkg - installed_pkg
    not_installed_pkg=($(diff reqpkg[@] installed_pkg[@]))
    echo -e "${RED}The following packages were not found in your system:${NC} ${not_installed_pkg[@]}"
    echo "Please, install them and try again."
    exit
fi

printf "The installation will be performaned on %s and %s\n" $DIR $LOCALPATH
askYesNo "Continue?" true
if [ $? -eq 0 ]; then
    printf "The installation was canceled.\n"
    exit
fi

#### Instalation ####

CONFIGFILE=~/.config/portable-env.sh
printf "#!/usr/bin/env sh\n# File generated by portable-environment install script\n\n" > $CONFIGFILE
TRASH=$(array_append "$TRASH" $CONFIGFILE)
printf "Updating \$PATH...\n"
printf "export PATH=%s:\$PATH\n" $LOCALPATH >> $CONFIGFILE
PATH=$LOCALPATH:$PATH
printf "\n. %s\n" $CONFIGFILE >> ~/.bashrc

# i (install) parameter
iEMACS=0; iSWIPROLOG=0
if [ $all -eq 1 ]; then
    installFonts
    iEMACS=1
fi
i=0
loop=1
while [ $loop -eq 1 ] && [ ! -z $clopts ] && [ $i -le ${#clopts[@]} ]; do
    clopt=${clopts[$(($install - 2 + $i))]}
    # Check for substring "-" (POSIX)
    case $clopt in
        -*)
            loop=0 ;;
        *)
            loop=1 ;;
    esac
    i=$((i + 1))
    if [ $loop -eq 0 ]; then break; fi

    case $clopt in
        clangd ) installClangd ;;
        fonts ) installFonts ;;
        swipl ) iSWIPROLOG=1 ;;
        emacs ) iEMACS=1 ;;
    esac
done

# Downloading the lastest nix-user-chroot realease from github. (May break if the release name changes)
curl -s https://api.github.com/repos/nix-community/nix-user-chroot/releases/latest |
    grep "tag_name" |
    awk '{print "https://github.com/nix-community/nix-user-chroot/releases/download/" substr($2, 2, length($2)-3) "/nix-user-chroot-bin-" substr($2, 2, length($2)-3) "-x86_64-unknown-linux-musl"}' |
    wget -i - -O nix-user-chroot
# Check if file exists and it's size to be sure it isn't an empty file
if [[ (! -e ./nix-user-chroot) || ($(du --apparent-size --block-size=1 "nix-user-chroot" | awk '{ print $1}') -le 1) ]]; then
    printf "It was not possible to retrieve the nix-user-chroot binary.\n"
    exit
fi
chmod u+x ./nix-user-chroot
mkdir -p $LOCALPATH
mv ./nix-user-chroot $LOCALPATH

# Installing Nix
mkdir -m 0755 ~/.nix
nix-user-chroot ~/.nix bash -c "curl -L https://nixos.org/nix/install | bash"
printf "alias nix-shell='nix-user-chroot %s bash -l'\n" $DIR >> $CONFIGFILE

# Installing SWIPL
if [ $iSWIPROLOG -eq 1 ]; then
runNix nix-env -iA nixpkgs.swiProlog &
printf "alias swipl-nix='nix-user-chroot ~/.nix bash -l -c swipl'\n" >> $CONFIGFILE
fi

#### Other configs ####

# Emacs config
if [ $iEMACS -eq 1 ]; then
runNix nix-env -iA nixpkgs.emacs
mkdir -p ~/.emacs.d/snippets/cc-mode/
curl -s -L https://raw.githubusercontent.com/ThwyIgo/dotfiles/main/.emacs.d/init.el > ~/.emacs.d/init.el
curl -s -L https://raw.githubusercontent.com/ThwyIgo/dotfiles/main/.emacs.d/snippets/cc-mode/forij > ~/.emacs.d/snippets/cc-mode/forij
curl -s -L https://raw.githubusercontent.com/ThwyIgo/dotfiles/main/.emacs.d/snippets/cc-mode/malloccast > ~/.emacs.d/snippets/cc-mode/malloccast
curl -s -L https://raw.githubusercontent.com/ThwyIgo/dotfiles/main/.emacs.d/snippets/cc-mode/realloc > ~/.emacs.d/snippets/cc-mode/realloc
genDesktopFile "emacs"
printf "alias emacs-nix='runNix.sh env XMODIFIERS= emacs -q -l ~/.emacs.d/init.el'\n" >> $CONFIGFILE
TRASH=$(array_append "$TRASH" ~/.emacs.d/)
runNix env XMODIFIERS= emacs -Q --script ~/.emacs.d/init.el &
fi

# Clean script
printf "#!/usr/bin/env sh
chmod -R u+rw ~/.nix
rm -rf " > $LOCALPATH/cleanNix.sh
printf '%s\n' "$TRASH" | while IFS= read element; do
    printf '%s ' "$(printf '%s\n' "$element" | array_element_decode)" >> $LOCALPATH/cleanNix.sh;
done
printf "\nrm \$0\n" >> $LOCALPATH/cleanNix.sh
chmod u+x $LOCALPATH/cleanNix.sh

#### Finishing up ####
wait -f
printf "Source ~/.bashrc or restart your terminal emulator\n"
printf "%bTo enter nix env, type 'nix-shell'%b\n" $GREEN $NC
printf "To remove Nix, run 'cleanNix.sh'\n"

exit
# runNix.sh . /home/thiago/.nix-profile/etc/profile.d/nix.sh
